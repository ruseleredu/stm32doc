"use strict";(self.webpackChunkstm_32_doc=self.webpackChunkstm_32_doc||[]).push([[6465],{101:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"software/stm32cubeprg","title":"STM32CubeProgrammer","description":"Software tool for programming STM32 products.","source":"@site/docs/software/STM32CubeProg.md","sourceDirName":"software","slug":"/stm32cubeprg","permalink":"/stm32doc/docs/stm32cubeprg","draft":false,"unlisted":false,"editUrl":"https://github.com/ruseleredu/stm32doc/edit/main/docs/software/STM32CubeProg.md","tags":[],"version":"current","frontMatter":{"id":"stm32cubeprg","title":"STM32CubeProgrammer","description":"Software tool for programming STM32 products.","slug":"/stm32cubeprg"},"sidebar":"tutorialSidebar","previous":{"title":"STM32CubeMonitor","permalink":"/stm32doc/docs/stm32cubemon"},"next":{"title":"Compiler Explorer","permalink":"/stm32doc/docs/godbolt"}}');var n=t(4848),s=t(8453);const i={id:"stm32cubeprg",title:"STM32CubeProgrammer",description:"Software tool for programming STM32 products.",slug:"/stm32cubeprg"},a=void 0,c={},l=[{value:"Software tool for programming STM32 products",id:"software-tool-for-programming-stm32-products",level:2},{value:"Error: Unable to get core ID",id:"error-unable-to-get-core-id",level:2}];function d(e){const r={a:"a",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h2,{id:"software-tool-for-programming-stm32-products",children:"Software tool for programming STM32 products"}),"\n",(0,n.jsx)(r.p,{children:"It provides an easy-to-use and efficient environment for reading, writing, and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART and USB DFU, I2C, SPI, and CAN)."}),"\n",(0,n.jsx)(r.p,{children:"STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as flash, RAM, and OTP) as well as external memories."}),"\n",(0,n.jsx)(r.p,{children:"STM32CubeProgrammer also allows option programming and upload, programming content verification, and programming automation through scripting."}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubeprog.html",children:"https://www.st.com/en/development-tools/stm32cubeprog.html"})}),"\n",(0,n.jsx)(r.h2,{id:"error-unable-to-get-core-id",children:"Error: Unable to get core ID"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Error: Unable to get core ID"}),"\n",(0,n.jsx)(r.li,{children:"Error: No STM32 target found! If your product embeds Debug Authentication, please perform a discovery using Debug Authentication"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"stm32cubeprog-hwRstPulse.png"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Aperte o Reset antes de conectar"}),"\n",(0,n.jsx)(r.li,{children:"Clique em conectar"}),"\n",(0,n.jsx)(r.li,{children:"Solte o bot\xe3o de reset!"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.img,{alt:"hwRstPulse",src:t(5117).A+"",width:"257",height:"321"})})]})}function m(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},5117:(e,r,t)=>{t.d(r,{A:()=>o});const o=t.p+"assets/images/stm32cubeprog-hwRstPulse-65a4452f6ec022fdf90e419cd58a8511.png"},8453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>a});var o=t(6540);const n={},s=o.createContext(n);function i(e){const r=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),o.createElement(s.Provider,{value:r},e.children)}}}]);