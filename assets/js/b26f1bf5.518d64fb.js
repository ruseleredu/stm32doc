"use strict";(self.webpackChunkstm_32_doc=self.webpackChunkstm_32_doc||[]).push([[6465],{28453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>i});var r=o(96540);const n={},s=r.createContext(n);function a(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(s.Provider,{value:t},e.children)}},50101:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"software/stm32cubeprg","title":"STM32CubeProgrammer","description":"Software tool for programming STM32 products.","source":"@site/docs/software/STM32CubeProg.md","sourceDirName":"software","slug":"/stm32cubeprg","permalink":"/stm32doc/docs/stm32cubeprg","draft":false,"unlisted":false,"editUrl":"https://github.com/ruseleredu/stm32doc/edit/main/docs/software/STM32CubeProg.md","tags":[],"version":"current","frontMatter":{"id":"stm32cubeprg","title":"STM32CubeProgrammer","description":"Software tool for programming STM32 products.","slug":"/stm32cubeprg"},"sidebar":"tutorialSidebar","previous":{"title":"STM32CubeMonitor","permalink":"/stm32doc/docs/stm32cubemon"},"next":{"title":"Compiler Explorer","permalink":"/stm32doc/docs/godbolt"}}');var n=o(74848),s=o(28453);const a={id:"stm32cubeprg",title:"STM32CubeProgrammer",description:"Software tool for programming STM32 products.",slug:"/stm32cubeprg"},i=void 0,m={},c=[{value:"Software tool for programming STM32 products",id:"software-tool-for-programming-stm32-products",level:2}];function d(e){const t={a:"a",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"software-tool-for-programming-stm32-products",children:"Software tool for programming STM32 products"}),"\n",(0,n.jsx)(t.p,{children:"It provides an easy-to-use and efficient environment for reading, writing, and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART and USB DFU, I2C, SPI, and CAN)."}),"\n",(0,n.jsx)(t.p,{children:"STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as flash, RAM, and OTP) as well as external memories."}),"\n",(0,n.jsx)(t.p,{children:"STM32CubeProgrammer also allows option programming and upload, programming content verification, and programming automation through scripting."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://www.st.com/en/development-tools/stm32cubeprog.html",children:"https://www.st.com/en/development-tools/stm32cubeprog.html"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);