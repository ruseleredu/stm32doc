"use strict";(self.webpackChunkstm_32_doc=self.webpackChunkstm_32_doc||[]).push([[8673],{562:(e,r,s)=>{s.d(r,{T9:()=>c,jC:()=>l,r8:()=>d});s(6540);var a=s(1470),n=s(9365),t=s(4907),i=s(1622),o=s(4848);function l(){return(0,o.jsx)("div",{children:(0,o.jsxs)(i.A,{summary:(0,o.jsx)("summary",{children:"Verifique o seu ambiente de desenvolvimento!"}),children:[(0,o.jsx)("p",{children:"Vers\xe3o do git e configura\xe7\xf5es:"}),(0,o.jsx)(t.A,{className:"language-bash",children:"git --version"}),(0,o.jsx)(t.A,{className:"language-bash",children:"git config --list --show-origin"}),(0,o.jsx)("p",{children:"Vers\xe3o do GitHub CLI e status de login:"}),(0,o.jsx)(t.A,{className:"language-bash",children:"gh --version"}),(0,o.jsx)(t.A,{className:"language-bash",children:"gh auth status"}),(0,o.jsx)("p",{children:"Vers\xe3o do VS Code e extens\xf5es instaladas:"}),(0,o.jsx)(t.A,{className:"language-bash",children:"code -v"}),(0,o.jsx)(t.A,{className:"language-bash",children:'code --list-extensions --profile "STM32"'}),(0,o.jsx)("p",{children:"Vers\xe3o do gcc e gdb instaladas:"}),(0,o.jsx)(t.A,{className:"language-bash",children:"gcc --version"}),(0,o.jsx)(t.A,{className:"language-bash",children:"gbd --version"})]})})}function c(){return(0,o.jsx)("div",{children:(0,o.jsxs)(i.A,{summary:(0,o.jsx)("summary",{children:"Configure a ferramenta git"}),children:[(0,o.jsx)("p",{children:"Configure o nome de usu\xe1rio para todos os reposit\xf3rios locais ligados \xe0s suas transa\xe7\xf5es de commit:"}),(0,o.jsx)(t.A,{className:"language-bash",children:'git config --global user.name "Your Name"'}),(0,o.jsx)("p",{children:" Configure o email de usu\xe1rio para todos os reposit\xf3rios locais ligados \xe0s suas transa\xe7\xf5es de commit:"}),(0,o.jsx)(t.A,{className:"language-bash",children:'git config --global user.email "you@example.com"'}),(0,o.jsx)("p",{children:"\xc9 recomendado verificar se a instala\xe7\xe3o do seu Git n\xe3o est\xe1 realizando nenhuma transforma\xe7\xe3o entre LFs e CRLFs."}),(0,o.jsx)(t.A,{className:"language-bash",children:"git config --global core.autocrlf false"}),(0,o.jsx)("p",{children:"Configure o Git para usar o Visual Studio Code (VS Code) como editor padr\xe3o para tarefas como escrever mensagens de commit ou rebases interativos"}),(0,o.jsx)(t.A,{className:"language-bash",children:'git config --global core.editor "code --wait"'}),(0,o.jsx)("p",{children:"Liste as configura\xe7\xf5es aplicadas:"}),(0,o.jsx)(t.A,{className:"language-bash",children:"git config --list --show-origin"})]})})}function d(){return(0,o.jsxs)(a.A,{children:[(0,o.jsxs)(n.A,{value:"STM32CubeMX",label:"STM32CubeMX",default:!0,children:[(0,o.jsx)("p",{children:(0,o.jsx)("b",{children:"STM32Cube initialization code generator."})}),(0,o.jsx)("ul",{children:(0,o.jsxs)("li",{children:[(0,o.jsx)("a",{href:"https://www.st.com/en/development-tools/stm32cubemx.html#get-software",target:"_blank",children:"STM32CubeMX"})," is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\xae Cortex\xae-M core or a partial Linux\xae Device Tree for Arm\xae Cortex\xae-A core, through a step-by-step process."]})})]}),(0,o.jsxs)(n.A,{value:"STM32CubeCLT",label:"STM32CubeCLT",children:[(0,o.jsx)("p",{children:(0,o.jsx)("b",{children:"STM32CubeCLT is an all-in-one multi-OS command-line toolset, which is part of the STM32Cube ecosystem."})}),(0,o.jsx)("ul",{children:(0,o.jsxs)("li",{children:[(0,o.jsx)("a",{href:"https://www.st.com/en/development-tools/stm32cubeclt.html#get-software",target:"_blank",children:"STM32CubeCLT"}),"  includes GNU C/C++ for Arm\xae toolchain executables, GDB debugger, and STM32CubeProgrammer (STM32CubeProg) utility. It provides system view descriptors for the entire STM32 MCU portfolio and associate each STM32 MCU and development board with the appropriate SVD."]})})]}),(0,o.jsxs)(n.A,{value:"STM32CubeProg",label:"STM32CubeProg",children:[(0,o.jsx)("p",{children:(0,o.jsx)("b",{children:"STM32CubeProg is an all-in-one multi-OS software tool for programming STM32 products."})}),(0,o.jsx)("ul",{children:(0,o.jsxs)("li",{children:[(0,o.jsx)("a",{href:"https://www.st.com/en/development-tools/stm32cubeprog.html#get-software",target:"_blank",children:"STM32CubeProg"})," provides an easy-to-use and efficient environment for reading, writing, and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART and USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer is delivered in GUI (graphical user interface) and CLI (command-line interface) versions."]})})]}),(0,o.jsxs)(n.A,{value:"STM32CubeMonitor",label:"STM32CubeMonitor",children:[(0,o.jsx)("p",{children:(0,o.jsx)("b",{children:"Monitoring tool to test STM32 applications at run-time."})}),(0,o.jsx)("ul",{children:(0,o.jsxs)("li",{children:[(0,o.jsx)("a",{href:"https://www.st.com/en/development-tools/stm32cubemonitor.html#get-software",target:"_blank",children:"STM32CubeMonitor"})," family of tools helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling."]})})]})]})}},1470:(e,r,s)=>{s.d(r,{A:()=>C});var a=s(6540),n=s(4164),t=s(3104),i=s(6347),o=s(205),l=s(7485),c=s(1682),d=s(679);function u(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:r,children:s}=e;return(0,a.useMemo)(()=>{const e=r??function(e){return u(e).map(({props:{value:e,label:r,attributes:s,default:a}})=>({value:e,label:r,attributes:s,default:a}))}(s);return function(e){const r=(0,c.XI)(e,(e,r)=>e.value===r.value);if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[r,s])}function m({value:e,tabValues:r}){return r.some(r=>r.value===e)}function p({queryString:e=!1,groupId:r}){const s=(0,i.W6)(),n=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,l.aZ)(n),(0,a.useCallback)(e=>{if(!n)return;const r=new URLSearchParams(s.location.search);r.set(n,e),s.replace({...s.location,search:r.toString()})},[n,s])]}function b(e){const{defaultValue:r,queryString:s=!1,groupId:n}=e,t=h(e),[i,l]=(0,a.useState)(()=>function({defaultValue:e,tabValues:r}){if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const s=r.find(e=>e.default)??r[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:r,tabValues:t})),[c,u]=p({queryString:s,groupId:n}),[b,g]=function({groupId:e}){const r=function(e){return e?`docusaurus.tab.${e}`:null}(e),[s,n]=(0,d.Dv)(r);return[s,(0,a.useCallback)(e=>{r&&n.set(e)},[r,n])]}({groupId:n}),f=(()=>{const e=c??b;return m({value:e,tabValues:t})?e:null})();(0,o.A)(()=>{f&&l(f)},[f]);return{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!m({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)},[u,g,t]),tabValues:t}}var g=s(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=s(4848);function j({className:e,block:r,selectedValue:s,selectValue:a,tabValues:i}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,t.a_)(),c=e=>{const r=e.currentTarget,n=o.indexOf(r),t=i[n].value;t!==s&&(l(r),a(t))},d=e=>{let r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const s=o.indexOf(e.currentTarget)+1;r=o[s]??o[0];break}case"ArrowLeft":{const s=o.indexOf(e.currentTarget)-1;r=o[s]??o[o.length-1];break}}r?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":r},e),children:i.map(({value:e,label:r,attributes:a})=>(0,x.jsx)("li",{role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:c,...a,className:(0,n.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":s===e}),children:r??e},e))})}function v({lazy:e,children:r,selectedValue:s}){const t=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){const e=t.find(e=>e.props.value===s);return e?(0,a.cloneElement)(e,{className:(0,n.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:t.map((e,r)=>(0,a.cloneElement)(e,{key:r,hidden:e.props.value!==s}))})}function T(e){const r=b(e);return(0,x.jsxs)("div",{className:(0,n.A)("tabs-container",f.tabList),children:[(0,x.jsx)(j,{...r,...e}),(0,x.jsx)(v,{...r,...e})]})}function C(e){const r=(0,g.A)();return(0,x.jsx)(T,{...e,children:u(e.children)},String(r))}},5117:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>u,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"tutorial-basics/tabs","title":"Tabs examples","description":"STM32Cube initialization code generator.","source":"@site/docs/tutorial-basics/tabs.md","sourceDirName":"tutorial-basics","slug":"/tabs","permalink":"/stm32doc/docs/tabs","draft":false,"unlisted":false,"editUrl":"https://github.com/ruseleredu/stm32doc/edit/main/docs/tutorial-basics/tabs.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"tabs","sidebar_position":2,"title":"Tabs examples","slug":"/tabs"},"sidebar":"tutorialSidebar","previous":{"title":"Docu YouTube videos","permalink":"/stm32doc/docs/tutorial-basics/docusaurus-videos"},"next":{"title":"Markdown Features","permalink":"/stm32doc/docs/tutorial-basics/markdown-features"}}');var n=s(4848),t=s(8453),i=s(1470),o=s(9365),l=s(562);const c={id:"tabs",sidebar_position:2,title:"Tabs examples",slug:"/tabs"},d=void 0,u={},h=[];function m(e){const r={a:"a",code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Details:s}=r;return s||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(l.r8,{}),"\n",(0,n.jsxs)(i.A,{children:[(0,n.jsxs)(o.A,{value:"STM32CubeMX",label:"STM32CubeMX",default:!0,children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"STM32Cube initialization code generator."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubemx.html",children:"STM32CubeMX"})," is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\xae Cortex\xae-M core or a partial Linux\xae Device Tree for Arm\xae Cortex\xae-A core, through a step-by-step process."]}),"\n"]})]}),(0,n.jsxs)(o.A,{value:"STM32CubeCLT",label:"STM32CubeCLT",children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"STM32CubeCLT is an all-in-one multi-OS command-line toolset, which is part of the STM32Cube ecosystem."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubeclt.html",children:"STM32CubeCLT"})," includes GNU C/C++ for Arm\xae toolchain executables, GDB debugger, and STM32CubeProgrammer (STM32CubeProg) utility. It provides system view descriptors for the entire STM32 MCU portfolio and associate each STM32 MCU and development board with the appropriate SVD."]}),"\n"]})]}),(0,n.jsxs)(o.A,{value:"ST-MCU-FINDER",label:"ST-MCU-FINDER",children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"STM32 and STM8 product finder for desktops."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/st-mcu-finder-pc.html",children:"ST-MCU-FINDER-PC"})," allows exploring and connecting to the complete portfolio of STM32 Arm\xae Cortex\xae-M, STM32 Arm\xae Cortex\xae-A7, and STM8 microcontrollers, microprocessors, development boards and examples directly from the developer\u2019s desktop environment."]}),"\n"]})]}),(0,n.jsxs)(o.A,{value:"STM32CubeProg",label:"STM32CubeProg",children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"STM32CubeProg is an all-in-one multi-OS software tool for programming STM32 products."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubeprog.html",children:"STM32CubeProg"})," provides an easy-to-use and efficient environment for reading, writing, and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART and USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer is delivered in GUI (graphical user interface) and CLI (command-line interface) versions."]}),"\n"]})]}),(0,n.jsxs)(o.A,{value:"STM32CubeMonitor",label:"STM32CubeMonitor",children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Monitoring tool to test STM32 applications at run-time."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubemonitor.html",children:"STM32CubeMonitor"})," family of tools helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling."]}),"\n"]})]}),(0,n.jsxs)(o.A,{value:"STM32CubeIDE",label:"STM32CubeIDE",children:[(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Integrated Development Environment for STM32."})}),(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"https://www.st.com/en/development-tools/stm32cubeide.html",children:"STM32CubeIDE"}),"  is an advanced C/C++ development platform with peripheral configuration, code generation, code compilation, and debug features for STM32 microcontrollers and microprocessors. It is based on the Eclipse\xae/CDT\u2122 framework and GCC toolchain for the development, and GDB for the debugging."]}),"\n"]})]})]}),"\n",(0,n.jsxs)(i.A,{children:[(0,n.jsxs)(o.A,{value:"vscode",label:"VS Code",children:[(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://code.visualstudio.com/",children:"VS Code"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://marketplace.visualstudio.com/items?itemName=stmicroelectronics.stm32-vscode-extension",children:"STM32Cube for Visual Studio Code"})}),"\n"]}),(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"winget install -e --id Microsoft.VisualStudioCode\n"})})]}),(0,n.jsxs)(o.A,{value:"git",label:"Git",default:!0,children:[(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://git-scm.com/",children:"git"})}),"\n"]}),(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"winget install -e --id Git.Git\n"})})]}),(0,n.jsxs)(o.A,{value:"gh",label:"GitHub CLI",children:[(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://cli.github.com/",children:"GitHub CLI"})}),"\n"]}),(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"winget install --id GitHub.cli\n"})})]})]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:'import Tabs from "@theme/Tabs";\nimport TabItem from "@theme/TabItem";\n'})}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:"Descri\xe7\xe3o aqui com tabela de op\xe7\xf5es..."}),(0,n.jsxs)(i.A,{children:[(0,n.jsx)(o.A,{value:"apple",label:"Apple",default:!0,children:(0,n.jsx)(r.p,{children:"This is an apple \ud83c\udf4e"})}),(0,n.jsx)(o.A,{value:"orange",label:"Orange",children:(0,n.jsx)(r.p,{children:"This is an orange \ud83c\udf4a"})}),(0,n.jsx)(o.A,{value:"banana",label:"Banana",children:(0,n.jsx)(r.p,{children:"This is a banana \ud83c\udf4c"})})]})]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:"Descri\xe7\xe3o aqui com tabela de op\xe7\xf5es e c\xf3digo..."}),(0,n.jsxs)(i.A,{children:[(0,n.jsx)(o.A,{value:"apple",label:"Apple",default:!0,children:(0,n.jsx)(r.p,{children:"This is an apple \ud83c\udf4e"})}),(0,n.jsx)(o.A,{value:"orange",label:"Orange",children:(0,n.jsx)(r.p,{children:"This is an orange \ud83c\udf4a"})}),(0,n.jsx)(o.A,{value:"github-cli",label:"GitHub CLI",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"gh auth login\n"})})})]})]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:"Descri\xe7\xe3o aqui com c\xf3digo..."}),(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"gh auth login\n"})})]})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}},9365:(e,r,s)=>{s.d(r,{A:()=>i});s(6540);var a=s(4164);const n={tabItem:"tabItem_Ymn6"};var t=s(4848);function i({children:e,hidden:r,className:s}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,a.A)(n.tabItem,s),hidden:r,children:e})}}}]);