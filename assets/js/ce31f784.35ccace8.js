"use strict";(self.webpackChunkstm_32_doc=self.webpackChunkstm_32_doc||[]).push([[6006],{28453:(t,o,e)=>{e.d(o,{R:()=>r,x:()=>a});var n=e(96540);const i={},s=n.createContext(i);function r(t){const o=n.useContext(s);return n.useMemo(function(){return"function"==typeof t?t(o):{...o,...t}},[o,t])}function a(t){let o;return o=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),n.createElement(s.Provider,{value:o},t.children)}},33698:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"software/stm32cubemon/stm32cubemonintro","title":"Intro","description":"Monitoring tool to test STM32 applications at run-time.","source":"@site/docs/software/stm32cubemon/intro.md","sourceDirName":"software/stm32cubemon","slug":"/stm32cubemonintro","permalink":"/stm32doc/docs/stm32cubemonintro","draft":false,"unlisted":false,"editUrl":"https://github.com/ruseleredu/stm32doc/edit/main/docs/software/stm32cubemon/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"stm32cubemonintro","sidebar_position":1,"title":"Intro","description":"Monitoring tool to test STM32 applications at run-time.","slug":"/stm32cubemonintro"},"sidebar":"tutorialSidebar","previous":{"title":"STM32CubeMonitor","permalink":"/stm32doc/docs/category/stm32cubemonitor"},"next":{"title":"ST Nodes","permalink":"/stm32doc/docs/stm32cubemonstnodes"}}');var i=e(74848),s=e(28453);const r={id:"stm32cubemonintro",sidebar_position:1,title:"Intro",description:"Monitoring tool to test STM32 applications at run-time.",slug:"/stm32cubemonintro"},a=void 0,c={},l=[{value:"Monitoring tool to test STM32 applications at run-time",id:"monitoring-tool-to-test-stm32-applications-at-run-time",level:2}];function m(t){const o={a:"a",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.h2,{id:"monitoring-tool-to-test-stm32-applications-at-run-time",children:"Monitoring tool to test STM32 applications at run-time"}),"\n",(0,i.jsx)(o.p,{children:"The STM32CubeMonitor family of tools helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. In addition to specialized versions (power, RF, USB-PD), the versatile STM32CubeMonitor provides a flow-based graphical editor to build custom dashboards simply, and quickly add widgets such as gauges, bar graphs and plots. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling."}),"\n",(0,i.jsx)(o.p,{children:(0,i.jsx)(o.img,{src:e(73784).A+"",width:"1010",height:"713"})}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:(0,i.jsx)(o.a,{href:"https://www.st.com/en/development-tools/stm32cubemonitor.html",children:"https://www.st.com/en/development-tools/stm32cubemonitor.html"})}),"\n"]})]})}function d(t={}){const{wrapper:o}={...(0,s.R)(),...t.components};return o?(0,i.jsx)(o,{...t,children:(0,i.jsx)(m,{...t})}):m(t)}},73784:(t,o,e)=>{e.d(o,{A:()=>n});const n=e.p+"assets/images/2025-10-06-11-03-48-1c29e810859843e7d9f26f504d1df0f3.png"}}]);